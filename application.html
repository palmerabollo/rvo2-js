<html>
<head>
	<script type="text/javascript" src="lib/common.js"></script>
	<script type="text/javascript" src="lib/agent.js"></script>
	<script type="text/javascript" src="lib/kdtree.js"></script>
	<script type="text/javascript" src="lib/simulator.js"></script>
	<title>Simulator</title>
	
	<style type="text/css">  
      canvas {
      	border: 1px dotted gray;
      	float: left;
      	margin-right: 2em;
      } 
      
      label {
      	display: block;
      }
    </style>
</head>
<body>
	<canvas id="board" width="500" height="500">
		Your browser does not support canvas.  Please use a modern browser with HTML5 support.
	</canvas>
	
	<div id="params">
		<label for="agents"># agents</label>
		<input type="text" name="agents" id="agents" value="12" /> (max = 12)
		
		<label for="radius">agent radius</label>
		<input type="text" name="radius" id="radius" value="5" />
		
		<br /><br />
		<input type="button" value="run simulation >>" id="run" onclick="run()">
	</div>
	
	<script type="text/javascript">
		$ = function(id) {
			return document.getElementById(id);
		};
		
		var Board = function() {
			var canvas = document.getElementById('board');
			var ctx = canvas.getContext('2d');
			
			var w = canvas.width;
			var h = canvas.height;

			this.drawObstacles = function(simulator) {
				var obstacles = simulator.getObstacles();

				if (obstacles.length) {
					ctx.fillStyle = "rgb(100,100,100)";
					ctx.beginPath();
					ctx.moveTo(obstacles[0].point.x + w/2, obstacles[0].point.y + h/2);
					for (var i=1; i<obstacles.length; i++) {
						ctx.lineTo(obstacles[i].point.x + w/2, obstacles[i].point.y + h/2);
					}
					ctx.closePath();
					ctx.fill();
				}
			};
			
			this.drawAgents = function(simulator) {
				
				var numAgents = simulator.getNumAgents();
				
				for (var i=0; i<numAgents; i++) {
					
					red   = Math.sin(3*i + 0) * 127 + 128;
					green = Math.sin(3*i + 2) * 127 + 128;
					blue  = Math.sin(3*i + 4) * 127 + 128;
					
					ctx.fillStyle = "red";
					
					var pos = simulator.getAgentPosition(i);
					var radius = simulator.getAgentRadius(i);
					ctx.beginPath();
					ctx.arc(pos.x + w/2 - 2, pos.y + h/2 - 2, radius, 0, Math.PI * 2, true);
					ctx.fill();
				}
			};
			
			this.drawGoals = function(simulator) {
				ctx.strokeStyle = "rgb(200,200,200)";
				
				var numAgents = simulator.getNumAgents();
				for (var i=0; i<numAgents; i++) {
					var pos = simulator.getGoal(i);
					var radius = simulator.getAgentRadius(i);
					ctx.beginPath();
					ctx.arc(pos.x + w/2 - 2, pos.y + h/2 - 2, radius, 0, Math.PI * 2, true);
					ctx.stroke();
				}
			};
			
			this.draw = function(simulator) {
				this.reset();
				this.drawObstacles(simulator);
				this.drawAgents(simulator);
				this.drawGoals(simulator);
			}
			
			this.reset = function() {
				ctx.clearRect(0,0,w,h);
			}
		}

		var setPreferredVelocities = function(simulator) {
			var stopped = 0;
			for (var i = 0; i < simulator.getNumAgents (); ++i) {
				if (RVOMath.absSq(simulator.getGoal(i).minus(simulator.getAgentPosition(i))) < simulator.getAgentRadius(i) * simulator.getAgentRadius(i)) {
					// Agent is within one radius of its goal, set preferred velocity to zero
					simulator.setAgentPrefVelocity (i, new Vector2 (0.0, 0.0));
					stopped++;
				} else {
					// Agent is far away from its goal, set preferred velocity as unit vector towards agent's goal.
					simulator.setAgentPrefVelocity(i, RVOMath.normalize (simulator.getGoal(i).minus(simulator.getAgentPosition(i))));
				}
			}
			return stopped;
		}
		
		var setupScenario = function(simulator)
		{
			// Specify global time step of the simulation.
			simulator.setTimeStep(0.25);
			
			// Specify default parameters for agents that are subsequently added.
			var velocity = new Vector2(2, 2);
			var radius = new Number($("radius").value); // TODO validate
			simulator.setAgentDefaults (200.0, 100, 1000, 1000, radius, 5.0, velocity);
			
			var NUM_AGENTS = $("agents").value;
			for (var i=0; i<NUM_AGENTS; i++) {
				var angle = i * (2*Math.PI) / NUM_AGENTS;
				var x = Math.cos(angle) * 240;
				var y = Math.sin(angle) * 240;
				simulator.addAgent(new Vector2 (x,y));
 			}
			
			// Create goals
			var goals = [];
			for (var i = 0; i < simulator.getNumAgents (); ++i) {
				goals.push(simulator.getAgentPosition(i).scale(-1));
			}
			simulator.addGoals(goals);
			
			// Add (polygonal) obstacle(s), specifying vertices in counterclockwise order.
			var vertices = [];
			/**
			vertices.push(new Vector2 (-40.0, -90.0));
			vertices.push(new Vector2 (40.0, -90.0));
			vertices.push(new Vector2 (40.0, -10.0));
			vertices.push(new Vector2 (-40.0, -10.0));
			*/
			simulator.addObstacle (vertices);
			
			
			// Process obstacles so that they are accounted for in the simulation.
			simulator.processObstacles ();
		}

		var simulator = Simulator.instance;
		var board = new Board();
		
		var interval;
		var run = function() {
			$("run").setAttribute("disabled", "disabled");
			
			clearInterval(interval);
			board.reset();
			setupScenario (simulator);
			
			var step = function() {
				setPreferredVelocities(simulator);
				simulator.run();
				board.draw(simulator);
				
				if (simulator.reachedGoal()) {
					clearInterval(interval);
				}
			}
			
			interval = setInterval(step, 5);
		}
	</script>
</body>
</html>
